Middle Function
---------------
Write a function called middle that takes an array and returns a new array that contains all but the first and last elements.

myArray = [1, 2, 3, 4]
middle(myArray)  # [2,3]. 

public int[] middle(int[] values) { 
		if (values == null || (values != null && values.length <= 2)) ----------------- O(1)
			return new int[0]; ---------------------------------------------------------------- O(1)

		int[] middle = new int[values.length - 2]; --------------------------- O(1), O(n)
		int count = 0;
		for (int i = 1; i < values.length-1; i++) {  --------------------------- O(n)
				middle[count++] = values[i];--------------------------- O(1), O(1)
		}
		return middle;--------------------------- O(1)
	}

time complexity is O(n) and space complexity is O(n)


2D Arrays
Given 2D array calculate the sum of diagonal elements.
------------------------------------------------------
Example

myArray2D= {{1,2,3},{4,5,6},{7,8,9}};
 
sumDiagonalElements(myArray2D) # 15

public int sumOfDiagnoal(int[][] arrays) {
		if (arrays == null || (arrays != null && arrays.length == 0) || (arrays.length != arrays[0].length)) --- O(1)
			return 0; ----------------------------------- O(1)
		int sum = 0; ----------------------------------- O(1), O(1)
		for (int i = 0; i < arrays.length; i++) { ----------------------------------- O(n)
			sum += arrays[i][i]; ----------------------------------- O(1),O(1)
		}
		return sum;----------------------------------- O(1)

	}

time complexity is O(n) and space complexity is O(1)

Best Score
----------
Given an array, write a function to get first, second best scores from the array and return it in new array.

Array may contain duplicates.

Example

myArray = {84,85,86,87,85,90,85,83,23,45,84,1,2,0}
firstSecond(myArray) // {90, 87}


public int[] findHighestScores(int[] arrays) {
		if (arrays == null || (arrays != null && arrays.length == 0)) ---------- O(1)
			return new int[0]; ---------- O(1), O(1)
		int[] best = new int[2]; ---------- O(2), O(1)
		for (int score : arrays) { ---------- O(n)
			if (score > best[0]) { ---------- O(1)
				best[1] = best[0]; ---------- O(1) , O(1)
				best[0] = score;---------- O(1) , O(1)
			} else if (score > best[1] && score < best[0]) ---------- O(1)
				best[1] = score; ---------- O(1) , O(1)
		} 
		return best; ---------- O(1)
	}

time complexity is O(n) and space complexity is O(1)


Missing Number
--------------
Write Java function called findMissingNumberInArray that takes an integer array containing n-1 unique elements from a range of 1 to n, with one missing number, and returns the missing number.

Example

myArray = {1,2,3,4,6}
findMissingNumberInArray(myArray, 6) // 5
Hint:

Use the formula (n * (n + 1)) / 2 which  calculates the sum of the first n natural numbers.


public int findMissingNumberInArray(int[] arrays) {
		if (arrays == null || (arrays != null && arrays.length == 0)) --------- O(1)
			return 0;--------- O(1)
		int n= arrays.length+1; --------- O(1),O(1)
		int expectedOutCome = (n*(n+1))/2; --------- O(1),O(1)
		int actualOutCome = 0; --------- O(1),O(1)
		for(int value: arrays) --------- O(n)
			actualOutCome+= value;--------- O(1),O(1)
		
		return expectedOutCome-actualOutCome; --------- O(1)
	}

time complexity is O(n) and space complexity is O(1)

Duplicate Number
---------------
Write a function which takes integer array as a parameter and returns a new integer array with unique elements. (remove duplicates)

Example

removeDuplicates({1, 1, 2, 2, 3, 4, 5})
Output : [1, 2, 3, 4, 5]


public static int[] removeDuplicates(int[] arr) {
		int[] uniqueArray = new int[arr.length]; ------------- O(1), O(n)
		boolean status = true; ------------- O(1), O(1)
		int count = 0;------------- O(1), O(1)
		for (int i = 0; i < arr.length; i++) { ------------- O(n)
			for (int k = 0; k < arr.length; k++) { ------------- O(n)
				if (uniqueArray[k] == arr[i]) { ------------- O(1)
					status = false; ------------- O(1), O(1)
					break; ------------- O(1)
				}
			}
			if (status) ------------- O(1)
				uniqueArray[count++] = arr[i]; ------------- O(1), O(1)
			status = true; ------------- O(1), O(1)

		}

		return Arrays.copyOf(uniqueArray, count); ------------- O(1), O(1)
	}

time complexity is O(n^2) and space complexity is O(n)

Another Method for duplicate removal

public static int[] removeDuplicates1(int[] arr) {
		int[] uniqueArray = new int[arr.length]; -------------- O(1),O(n)
		int count = 0;-------------- O(1),O(1)

		uniqueArray[count++] = arr[0]; -------------- O(1),O(1)
		for (int i = 1; i < arr.length; i++) { -------------- O(1)
			if (arr[i] != arr[i - 1]) -------------- O(1)
				uniqueArray[count++] = arr[i]; -------------- O(1),O(1)
		}
		return Arrays.copyOf(uniqueArray, count); -------------- O(1),O(1)
	}

time complexity is O(n) and space complexity is O(n)
